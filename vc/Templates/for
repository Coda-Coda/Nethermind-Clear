import Clear.ReasoningPrinciple

\<imports>

namespace \<contract>

set_option autoImplicit false

section

open Clear EVMState Ast Expr Stmt FunctionDefinition State Interpreter ExecLemmas OutOfFuelLemmas Abstraction YulNotation PrimOps ReasoningPrinciple Utilities \<opens>

lemma \<statement_name>_post_abs_of_code {s₀ : State} {fuel : Nat} :
  ∀ s₉, exec fuel (Block \<statement_name>_post) s₀ = s₉ →
        Spec APost_\<statement_name> s₀ s₉ :=
    λ _ h ↦ \<statement_name>_concrete_of_post_abs (\<statement_name>_post_concrete_of_code.2 h)

lemma \<statement_name>_body_abs_of_code {s₀ : State} {fuel : Nat} :
  ∀ s₉, exec fuel (Block \<statement_name>_body) s₀ = s₉ →
        Spec ABody_\<statement_name> s₀ s₉ :=
    λ _ h ↦ \<statement_name>_concrete_of_body_abs (\<statement_name>_body_concrete_of_code.2 h)

-- | Code → Abstract (autogenerated).
lemma \<statement_name>_abs_of_code {s₀ fuel} : ∀ s₉, exec fuel \<statement_name> s₀ = s₉ → Spec AFor_\<statement_name> s₀ s₉ := by
  intros s₉
  intros hcode
  apply reasoning_principle_3 \<statement_name>_cond \<statement_name>_post \<statement_name>_body ACond_\<statement_name> APost_\<statement_name> ABody_\<statement_name> AFor_\<statement_name> AZero_\<statement_name> AOk_\<statement_name> AContinue_\<statement_name> ABreak_\<statement_name> ALeave_\<statement_name> @\<statement_name>_cond_abs_of_code @\<statement_name>_post_abs_of_code @\<statement_name>_body_abs_of_code hcode

end

end \<contract>
